##########################################################
# Create edx set, validation set (final hold-out test set)
##########################################################

# Note: this process could take a couple of minutes

if(!require(tidyverse)) install.packages("tidyverse", 
                                         repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", 
                                     repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", 
                                          repos = "http://cran.us.r-project.org")

#Install package ggthemes to manage themes, geoms, and scales for 'ggplot2'
if(!require(ggthemes)) 
  install.packages("ggthemes", repos = "http://cran.us.r-project.org")

#This package simplifies the way to manipulate the HTML or 'LaTeX' codes 
#generated by 'kable()' and allows users to construct complex tables 
#and customize styles using a readable syntax
if(!require(kableExtra)) 
  install.packages("kableExtra", repos = "http://cran.us.r-project.org")

#This package make Dealing with Dates a Little Easier
if(!require(lubridate)) 
  install.packages("lubridate", repos = "http://cran.us.r-project.org")


library(tidyverse)
library(caret)
library(data.table)
library(ggthemes)
library(scales)
library(kableExtra)
library(lubridate)

# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip

dl <- tempfile()

download.file("http://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)

ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")

movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(movieId),
                                           title = as.character(title),
                                           genres = as.character(genres))


movielens <- left_join(ratings, movies, by = "movieId")


# Validation set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.5 or earlier, use `set.seed(1)`
test_index <- createDataPartition(y = movielens$rating, 
                                  times = 1, 
                                  p = 0.1, 
                                  list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]


# Make sure userId and movieId in validation set are also in edx set
validation <- temp %>% 
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")

# Add rows removed from validation set back into edx set
removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)

#The edx set is used for training and testing, and the validation set is used for final validation to simulate the new data.

#Here, we split the edx set in 2 parts: the training set and the test set.

#The model building is done in the training set, and the test set is used to test the model. When the model is complete, we use the validation set to calculate the final RMSE. We use the same procedure used to create edx and validation sets.

#The training set will be 90% of edx data and the test set will be the remaining 10%.
set.seed(1, sample.kind="Rounding")
test_index <- createDataPartition(y = edx$rating, 
                                  times = 1, 
                                  p = 0.1, 
                                  list = FALSE)
train_set <- edx[-test_index,]
temp <- edx[test_index,]

# Make sure userId and movieId in test set are also in train set
test_set <- temp %>% 
  semi_join(train_set, by = "movieId") %>%
  semi_join(train_set, by = "userId")

# Add rows removed from test set back into train set
removed <- anti_join(temp, test_set)
train_set <- rbind(train_set, removed)

rm(test_index, temp, removed)


#Data Exploration
#Let's start by exploring the structure and dimensions of edx

#Structure
str(edx)

#Dimension
dim(edx)


#High ratings are predominant.
edx %>% group_by(rating) %>% 
  summarise(count=n()) %>%
  ggplot(aes(x=rating, y=count)) + 
  geom_line() +
  geom_point() +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  ggtitle("Rating Distribution") + 
  xlab("Rating") +
  ylab("Count") +
  theme_economist()

#We carry out a rating analysis based on users

#########
##USERS
#########

#Rating distribution based on Users is right skewed
edx %>% group_by(userId) %>%
  summarise(n=n()) %>%
  ggplot(aes(n)) +
  geom_histogram(color = "white") +
  scale_x_log10() + 
  ggtitle("Rating distribution based on Users") +
  xlab("Number of Ratings") +
  ylab("Number of Users") + 
  scale_y_continuous(labels = comma) + 
  theme_economist()

########
#Movies
########

#Rating distribution based on Movies is almost symmetric
edx %>% group_by(movieId) %>%
  summarise(n=n()) %>%
  ggplot(aes(n)) +
  geom_histogram(color = "white") +
  scale_x_log10() + 
  ggtitle("Rating distribution based on Movies") +
  xlab("Number of Ratings") +
  ylab("Number of Movies") + 
  theme_economist()

########
#Genres
########
head(edx, 20) %>% kable(caption = "Movies") %>%
  kable_styling(font_size = 10, position = "center",
                latex_options = c("scale_down","HOLD_position")) 
#We can see that different movies belong to multiple genres

tibble(count = str_count(edx$genres, fixed("|")), genres = edx$genres) %>% 
  group_by(count, genres) %>%
  summarise(n = n()) %>%
  arrange(-count) %>% 
  head() %>% kable(caption = "Genres") %>%
  kable_styling(font_size = 10, position = "center",
                latex_options = c("scale_down","HOLD_position"))


#The plots show a clear effect of genres on the rating
temp_genre <- edx %>% 
  separate_rows(genres,sep = "\\|") %>% mutate(value=1) %>%
  group_by(genres) %>%
  summarize(n=n()) %>%
  ungroup() %>%
  mutate(sumN = sum(n), percentage = n/sumN) %>%
  arrange(-percentage)

temp_genre %>%
  ggplot(aes(reorder(genres, percentage), percentage, fill= percentage)) +
  geom_bar(stat = "identity") + coord_flip() +
  scale_fill_distiller(palette = "YlOrRd") + 
  labs(y = "Percentage", x = "Genre") +
  ggtitle("Distribution of Genres by Percent Rated")

edx %>% group_by(genres) %>%
  summarize(n = n(), avg = mean(rating), se = sd(rating)/sqrt(n())) %>%
  filter(n >= 1000) %>% 
  mutate(genres = reorder(genres, avg)) %>%
  ggplot(aes(x = genres, y = avg, ymin = avg - 2*se, ymax = avg + 2*se)) + 
  geom_point() +
  geom_errorbar() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

#######
#Time
#######
edx <- mutate(edx, date = as_datetime(timestamp))
validation <- mutate(validation, date = as_datetime(timestamp))
test_set <- mutate(test_set, date = as_datetime(timestamp))
train_set <- mutate(train_set, date = as_datetime(timestamp))


edx %>% mutate(date = round_date(date, unit = "week")) %>%
  group_by(date) %>%
  summarize(rating = mean(rating)) %>%
  ggplot(aes(date, rating)) +
  geom_point() +
  geom_smooth() + 
  theme_economist()

#The plot shows that time ha not strong effect on average rating



##########################################################################
########################Data Cleaning#####################################
##########################################################################
train_set <- train_set %>% select(userId, movieId, date, rating, title)
test_set  <- test_set  %>% select(userId, movieId, date, rating, title)


#Modeling

#Model Evaluation Functions

# Define Root Mean Squared Error (RMSE)
RMSE <- function(original_ratings, predicted_ratings){
  sqrt(mean((original_ratings - predicted_ratings)^2))
}

set.seed(1, sample.kind = "Rounding")

# Create the probability of each rating
random_prob <- function(x, y) mean(x == y)
rating <- seq(0.5,5,0.5)

# Estimate the probability of each rating with Monte Carlo simulation
B <- 10^3
monte_carlo <- replicate(B, {
  rec <- sample(train_set$rating, 100, replace = TRUE)
  sapply(rating, random_prob, x = rec)
})

monte_carlo_prob <- sapply(1:nrow(monte_carlo), 
                           function(ind) mean(monte_carlo[ind,]))

# Predict random ratings
random_prediction <- sample(rating, size = nrow(test_set), 
                            replace = TRUE, 
                            prob = monte_carlo_prob)

# Create a table with the error results
monte_carlo_result <- tibble(Method = "Random prediction", 
                             RMSE = RMSE(test_set$rating, random_prediction))

result <- tibble(Method = "Project target", RMSE = 0.86490)

result <- bind_rows(result,
                    monte_carlo_result)

result %>% kable(caption = "Result") %>%
  kable_styling(font_size = 10, position = "center",
                latex_options = c("scale_down","HOLD_position"))                    


#Linear Model
set.seed(1, sample.kind="Rounding")
#Evaluate mean of the ratings
mean_rating <- mean(train_set$rating)

#Add movie bias
movie_bias <- train_set %>% 
  group_by(movieId) %>% 
  summarize(b_i = mean(rating - mean_rating))

#Show movie bias
#Shows an asymmetric distribution
movie_bias %>% ggplot(aes(x = b_i)) + 
  geom_histogram(bins=10, col = I("white")) +
  ggtitle("Movie bias distribution") +
  xlab("Movie bias") +
  ylab("Count") +
  scale_y_continuous(labels = comma) + 
  theme_economist()


#Add user bias
user_bias <- train_set %>% 
  left_join(movie_bias, by = 'movieId') %>%
  group_by(userId) %>%
  summarize(b_u = mean(rating - mean_rating - b_i))


#Show user bias
#It's almost symmetrical
user_bias %>% ggplot(aes(x = b_u)) + 
  geom_histogram(bins=10, col = I("white")) +
  ggtitle("User bias distribution") +
  xlab("User bias") +
  ylab("Count") +
  scale_y_continuous(labels = comma) + 
  theme_economist()

regression_prediction <- test_set %>% 
  left_join(movie_bias, by='movieId') %>%
  left_join(user_bias, by='userId') %>%
  mutate(prediction = mean_rating + b_i + b_u) %>%
  .$prediction

regression_rmse <- RMSE(test_set$rating, 
                             regression_prediction)

regression_rmse

regression_prediction_result <- tibble(Method = "Linear regression prediction", 
                                       RMSE = RMSE(test_set$rating, 
                                                   regression_prediction))

result <- bind_rows(result,
                    regression_prediction_result)

result %>% kable(caption = "Results") %>%
  kable_styling(font_size = 10, position = "center",
                latex_options = c("scale_down","HOLD_position"))

#Linear regression method improves the performance in the calculation of the RMSE 
#compared to Random prediction


#REGULARIZATION
set.seed(1, sample.kind="Rounding")
regularization <- function(lambda, training, test){
  
  #Mean
  mean_rating <- mean(training$rating)
  
  #Movie bias
  movie_bias <- training %>% 
    group_by(movieId) %>%
    summarize(b_i = sum(rating - mean_rating)/(n()+lambda))
  
  #User bias
  user_bias <- training %>% 
    left_join(movie_bias, by="movieId") %>%
    filter(!is.na(b_i)) %>%
    group_by(userId) %>%
    summarize(b_u = sum(rating - mean_rating - b_i)/(n()+lambda))
  
  #Prediction
  predicted_ratings <- test %>% 
    left_join(movie_bias, by = "movieId") %>%
    left_join(user_bias, by = "userId") %>%
    filter(!is.na(b_i), !is.na(b_u)) %>%
    mutate(predicted = mean_rating + b_i + b_u) %>%
    pull(predicted)
  
  return(RMSE(test$rating, predicted_ratings))
}

# Definition of lambdas 
lambdas <- seq(0, 10, 0.25)

#Tuning
rmses <- sapply(lambdas, 
                regularization, 
                training = train_set, 
                test = test_set)

tibble(Lambda = lambdas, RMSE = rmses) %>%
  ggplot(aes(x = Lambda, y = RMSE)) +
  geom_point() +
  ggtitle("Regularization") +
  theme_economist()

lambda <- lambdas[which.min(rmses)]
lambda

#Mean
mean_rating <- mean(train_set$rating)

#Movie bias
movie_bias <- train_set %>% 
  group_by(movieId) %>%
  summarize(b_i = sum(rating - mean_rating)/(n()+lambda))

#User bias
user_bias <- train_set %>% 
  left_join(movie_bias, by="movieId") %>%
  filter(!is.na(b_i)) %>%
  group_by(userId) %>%
  summarize(b_u = sum(rating - mean_rating - b_i)/(n()+lambda))


#Prediction
regularization_prediction <- test_set %>% 
  left_join(movie_bias, by = "movieId") %>%
  left_join(user_bias, by = "userId") %>%
  filter(!is.na(b_i), !is.na(b_u)) %>%
  mutate(predicted = mean_rating + b_i + b_u) %>%
  pull(predicted)

regularization_rmse <- RMSE(test_set$rating, regularization_prediction)

regularization_result <- tibble(Method = "Regularization prediction", 
                                RMSE = regularization_rmse)
result <- bind_rows(result, 
                    regularization_result)

result %>% kable(caption = "Results") %>%
  kable_styling(font_size = 10, position = "center",
                latex_options = c("scale_down","HOLD_position"))


#Regularization provides a slight improvement in the RMSE estimate


################################################
#############Matrix factorization###############
################################################

#Install recosystem package which provides the complete solution
#for a recommendation system using matrix factorization
if(!require(recosystem)) 
  install.packages("recosystem", repos = "http://cran.us.r-project.org")

library(recosystem)

set.seed(1, sample.kind = "Rounding")

#Create matrices
train_data <-  with(train_set, data_memory(user_index = userId, 
                                           item_index = movieId, 
                                           rating     = rating))

test_data  <-  with(test_set,  data_memory(user_index = userId, 
                                           item_index = movieId, 
                                           rating     = rating))

#Create the model object
model_object <-  Reco()

#Select the best tuning parameters
best_tuning <-  model_object$tune(train_data, 
                           opts = list(dim = c(10, 20, 30), 
                                       lrate = c(0.1, 0.2),
                                       costp_l1 = c(0.01, 0.1), 
                                       costq_l1 = c(0.01, 0.1),
                                       nthread  = 4, 
                                       niter = 10))

#Train model  
model_object$train(train_data, 
                   opts = c(best_tuning$min, nthread = 4, niter = 20))

#Predict  
matrix_prediction <-  model_object$predict(test_data, out_memory())

matrix_rmse <-  RMSE(test_set$rating, 
                     matrix_prediction)

matrix_result <- tibble(Method = "Matrix factorization prediction", 
                        RMSE = matrix_rmse)

result <- bind_rows(result, 
                    matrix_result)

result %>% kable(caption = "Results") %>%
  kable_styling(font_size = 10, position = "center",
                latex_options = c("scale_down","HOLD_position"))

#Matrix factorization further improves the performance in calculating the RMSE

################################################################
##########FINAL VALIDATION######################################
################################################################

####MATRIX FACTORIZATION
set.seed(1, sample.kind = "Rounding")

#Create matrix
edx_data <-  with(edx, data_memory(user_index = userId,
                                   item_index = movieId,
                                   rating     = rating))

validation_data  <-  with(validation,  data_memory(user_index = userId,
                                                   item_index = movieId,
                                                   rating     = rating))

#Create the model object
final_model_object <-  Reco()

#Select the best tuning parameters
final_best_tuning <-  final_model_object$tune(edx_data,
                                opts = list(dim = c(10, 20, 30),
                                       lrate = c(0.1, 0.2),
                                       costp_l1 = c(0.01, 0.1),
                                       costq_l1 = c(0.01, 0.1),
                                       nthread  = 4,
                                       niter = 10))

#Train model
final_model_object$train(edx_data,
                   opts = c(final_best_tuning$min, 
                            nthread = 4, 
                            niter = 20))

#Predict
final_matrix_prediction <-  final_model_object$predict(validation_data, 
                                                       out_memory())

final_matrix_rmse <- RMSE(validation$rating,
                          final_matrix_prediction)

final_matrix_result <- tibble(Method = "Final Matrix factorization prediction",
                              RMSE = final_matrix_rmse)

result <- tibble(Method = "Project target", RMSE = 0.86490)

result <- bind_rows(result, 
                    final_matrix_result)

result %>% kable(caption = "Results") %>%
  kable_styling(font_size = 10, position = "center",
                latex_options = c("scale_down","HOLD_position"))
